// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nexus

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type NexusScript struct {
	pulumi.CustomResourceState

	// The content of this script.
	Content pulumi.StringOutput `pulumi:"content"`
	// The name of the script.
	Name pulumi.StringOutput `pulumi:"name"`
	// The type of the script. Default: `groovy`
	Type pulumi.StringPtrOutput `pulumi:"type"`
}

// NewNexusScript registers a new resource with the given unique name, arguments, and options.
func NewNexusScript(ctx *pulumi.Context,
	name string, args *NexusScriptArgs, opts ...pulumi.ResourceOption) (*NexusScript, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Content == nil {
		return nil, errors.New("invalid value for required argument 'Content'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource NexusScript
	err := ctx.RegisterResource("nexus:index/nexusScript:NexusScript", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNexusScript gets an existing NexusScript resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNexusScript(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NexusScriptState, opts ...pulumi.ResourceOption) (*NexusScript, error) {
	var resource NexusScript
	err := ctx.ReadResource("nexus:index/nexusScript:NexusScript", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NexusScript resources.
type nexusScriptState struct {
	// The content of this script.
	Content *string `pulumi:"content"`
	// The name of the script.
	Name *string `pulumi:"name"`
	// The type of the script. Default: `groovy`
	Type *string `pulumi:"type"`
}

type NexusScriptState struct {
	// The content of this script.
	Content pulumi.StringPtrInput
	// The name of the script.
	Name pulumi.StringPtrInput
	// The type of the script. Default: `groovy`
	Type pulumi.StringPtrInput
}

func (NexusScriptState) ElementType() reflect.Type {
	return reflect.TypeOf((*nexusScriptState)(nil)).Elem()
}

type nexusScriptArgs struct {
	// The content of this script.
	Content string `pulumi:"content"`
	// The name of the script.
	Name *string `pulumi:"name"`
	// The type of the script. Default: `groovy`
	Type *string `pulumi:"type"`
}

// The set of arguments for constructing a NexusScript resource.
type NexusScriptArgs struct {
	// The content of this script.
	Content pulumi.StringInput
	// The name of the script.
	Name pulumi.StringPtrInput
	// The type of the script. Default: `groovy`
	Type pulumi.StringPtrInput
}

func (NexusScriptArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*nexusScriptArgs)(nil)).Elem()
}

type NexusScriptInput interface {
	pulumi.Input

	ToNexusScriptOutput() NexusScriptOutput
	ToNexusScriptOutputWithContext(ctx context.Context) NexusScriptOutput
}

func (*NexusScript) ElementType() reflect.Type {
	return reflect.TypeOf((**NexusScript)(nil)).Elem()
}

func (i *NexusScript) ToNexusScriptOutput() NexusScriptOutput {
	return i.ToNexusScriptOutputWithContext(context.Background())
}

func (i *NexusScript) ToNexusScriptOutputWithContext(ctx context.Context) NexusScriptOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NexusScriptOutput)
}

// NexusScriptArrayInput is an input type that accepts NexusScriptArray and NexusScriptArrayOutput values.
// You can construct a concrete instance of `NexusScriptArrayInput` via:
//
//          NexusScriptArray{ NexusScriptArgs{...} }
type NexusScriptArrayInput interface {
	pulumi.Input

	ToNexusScriptArrayOutput() NexusScriptArrayOutput
	ToNexusScriptArrayOutputWithContext(context.Context) NexusScriptArrayOutput
}

type NexusScriptArray []NexusScriptInput

func (NexusScriptArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NexusScript)(nil)).Elem()
}

func (i NexusScriptArray) ToNexusScriptArrayOutput() NexusScriptArrayOutput {
	return i.ToNexusScriptArrayOutputWithContext(context.Background())
}

func (i NexusScriptArray) ToNexusScriptArrayOutputWithContext(ctx context.Context) NexusScriptArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NexusScriptArrayOutput)
}

// NexusScriptMapInput is an input type that accepts NexusScriptMap and NexusScriptMapOutput values.
// You can construct a concrete instance of `NexusScriptMapInput` via:
//
//          NexusScriptMap{ "key": NexusScriptArgs{...} }
type NexusScriptMapInput interface {
	pulumi.Input

	ToNexusScriptMapOutput() NexusScriptMapOutput
	ToNexusScriptMapOutputWithContext(context.Context) NexusScriptMapOutput
}

type NexusScriptMap map[string]NexusScriptInput

func (NexusScriptMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NexusScript)(nil)).Elem()
}

func (i NexusScriptMap) ToNexusScriptMapOutput() NexusScriptMapOutput {
	return i.ToNexusScriptMapOutputWithContext(context.Background())
}

func (i NexusScriptMap) ToNexusScriptMapOutputWithContext(ctx context.Context) NexusScriptMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NexusScriptMapOutput)
}

type NexusScriptOutput struct{ *pulumi.OutputState }

func (NexusScriptOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NexusScript)(nil)).Elem()
}

func (o NexusScriptOutput) ToNexusScriptOutput() NexusScriptOutput {
	return o
}

func (o NexusScriptOutput) ToNexusScriptOutputWithContext(ctx context.Context) NexusScriptOutput {
	return o
}

// The content of this script.
func (o NexusScriptOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v *NexusScript) pulumi.StringOutput { return v.Content }).(pulumi.StringOutput)
}

// The name of the script.
func (o NexusScriptOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *NexusScript) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The type of the script. Default: `groovy`
func (o NexusScriptOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NexusScript) pulumi.StringPtrOutput { return v.Type }).(pulumi.StringPtrOutput)
}

type NexusScriptArrayOutput struct{ *pulumi.OutputState }

func (NexusScriptArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NexusScript)(nil)).Elem()
}

func (o NexusScriptArrayOutput) ToNexusScriptArrayOutput() NexusScriptArrayOutput {
	return o
}

func (o NexusScriptArrayOutput) ToNexusScriptArrayOutputWithContext(ctx context.Context) NexusScriptArrayOutput {
	return o
}

func (o NexusScriptArrayOutput) Index(i pulumi.IntInput) NexusScriptOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NexusScript {
		return vs[0].([]*NexusScript)[vs[1].(int)]
	}).(NexusScriptOutput)
}

type NexusScriptMapOutput struct{ *pulumi.OutputState }

func (NexusScriptMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NexusScript)(nil)).Elem()
}

func (o NexusScriptMapOutput) ToNexusScriptMapOutput() NexusScriptMapOutput {
	return o
}

func (o NexusScriptMapOutput) ToNexusScriptMapOutputWithContext(ctx context.Context) NexusScriptMapOutput {
	return o
}

func (o NexusScriptMapOutput) MapIndex(k pulumi.StringInput) NexusScriptOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NexusScript {
		return vs[0].(map[string]*NexusScript)[vs[1].(string)]
	}).(NexusScriptOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NexusScriptInput)(nil)).Elem(), &NexusScript{})
	pulumi.RegisterInputType(reflect.TypeOf((*NexusScriptArrayInput)(nil)).Elem(), NexusScriptArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NexusScriptMapInput)(nil)).Elem(), NexusScriptMap{})
	pulumi.RegisterOutputType(NexusScriptOutput{})
	pulumi.RegisterOutputType(NexusScriptArrayOutput{})
	pulumi.RegisterOutputType(NexusScriptMapOutput{})
}
